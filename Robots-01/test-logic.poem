#lang poem

(require rackunit)
(require rackunit/text-ui)
(require "logic.poem")

(define-test-suite relations-suite

  (test-case
   "name+arity->functor"
   (check-equal? (name+arity->functor 'foo 2) 'foo/2))

  (test-case
   "predicate-names->functors"
   (check-equal? (predicate-names->functors '?x) '?x)
   (check-equal? (predicate-names->functors '(foo ?x ?y)) '(foo/2 ?x ?y))
   (check-equal? (predicate-names->functors '(bar)) '(bar/0))
   (check-equal? (predicate-names->functors '(foo (bar ?x) (baz ?x ?y)))
		 '(foo/2 (bar/1 ?x) (baz/2 ?x ?y)))
   (check-equal? (predicate-names->functors '((foo ?x))) '((foo/1 ?x))))

  (test-case
   "parse-functor-description 1"
   (enable-checks-for-parse-functor-description? #t)
   (check-exn #rx"^Functor name is not a symbol: \"foo\"$"
	      (thunk (parse-functor-description "foo" "bar" "2")))
   (check-exn #rx"^Relation name is not a symbol: \"bar\"$"
	      (thunk (parse-functor-description 'foo/2 "bar" "2")))
   (check-exn #rx"^Arity is not a non-negative integer: \"2\"$"
	      (thunk (parse-functor-description 'foo/2 'bar "2")))
   (check-exn #rx"^Name and arity do not match functor: bar 2 foo/2$"
	      (thunk (parse-functor-description 'foo/2 'bar 2)))
   (check-exn #rx"^Name and arity do not match functor: foo 3 foo/2$"
	      (thunk (parse-functor-description 'foo/2 'foo 3))))

  (test-case
   "parse-functor-description 2"
   (enable-checks-for-parse-functor-description? #t)
   (define-values (functor name arity)
     (parse-functor-description 'foo/2 'foo 2))
   (check-equal? functor 'foo/2)
   (check-equal? name 'foo)
   (check-equal? arity 2))

  (test-case
   "parse-functor-description 3"
   (enable-checks-for-parse-functor-description? #t)
   (define-values (functor name arity)
     (parse-functor-description #f 'foo 2))
   (check-equal? functor 'foo/2)
   (check-equal? name 'foo)
   (check-equal? arity 2))

  (test-case
   "parse-functor-description 4"
   (enable-checks-for-parse-functor-description? #t)
   (check-exn #rx"^Functor name is not of the form name/arity: foo$"
	      (thunk (parse-functor-description 'foo #f #f)))
   (check-exn #rx"^Functor name is not of the form name/arity: foo/bar$"
	      (thunk (parse-functor-description 'foo/bar 'foo #f)))
   (check-exn #rx"^Functor name is not of the form name/arity: /123$"
	      (thunk (parse-functor-description '|/123| #f 123))))

  (test-case
   "parse-functor-description 5"
   (enable-checks-for-parse-functor-description? #t)
   (define-values (functor name arity)
     (parse-functor-description 'foo/2 #f #f))
   (check-equal? functor 'foo/2)
   (check-equal? name 'foo)
   (check-equal? arity 2))

  (test-case
   "parse-functor-description 6"
   (enable-checks-for-parse-functor-description? #t)
   (check-exn #rx"^Functor name and relation name do not match: foo/2 bar$"
	      (thunk (parse-functor-description 'foo/2 'bar #f))))

  (test-case
   "parse-functor-description 7"
   (enable-checks-for-parse-functor-description? #t)
   (define-values (functor name arity)
     (parse-functor-description 'foo/2 'foo #f))
   (check-equal? functor 'foo/2)
   (check-equal? name 'foo)
   (check-equal? arity 2))

  (test-case
   "parse-functor-description 8"
   (enable-checks-for-parse-functor-description? #t)
   (define-values (functor name arity)
     (parse-functor-description 'foo/2 #f 2))
   (check-equal? functor 'foo/2)
   (check-equal? name 'foo)
   (check-equal? arity 2))

  (test-case
   "parse-functor-description 9"
   (enable-checks-for-parse-functor-description? #t)
   (check-exn #rx"^Functor arity and explicit arity do not match: 2 3$"
	      (thunk (parse-functor-description 'foo/2 #f 3))))

  (test-case
   "parse-functor-description 10"
   (enable-checks-for-parse-functor-description? #t)
   (check-exn #rx"^Neither name \\+ arity nor functor were specified.$"
	      (thunk (parse-functor-description #f 'foo #f))))

  (test-case
   "parse-functor-description 11"
   (enable-checks-for-parse-functor-description? #t)
   (check-exn #rx"^Neither name \\+ arity nor functor were specified.$"
	      (thunk (parse-functor-description #f #f 3))))

  (test-case
   "make <relation> 1"
   (clear-all-relations)
   (define f/2-rel (make <relation> :name 'f :arity 2))
   (check-equal? (name f/2-rel) 'f)
   (check-equal? (arity f/2-rel) 2)
   (check-equal? (functor f/2-rel) 'f/2)
   (check-equal? (clauses f/2-rel) '()))

  (test-case
   "make <relation> 2"
   (clear-all-relations)
   (let ((clause (make <horn-fact> :functor 'f/2 :head '(f/2 ?x ?y))))
     (define f/2-rel (make <relation>
		       :name 'f :arity 2
		       :clauses (list clause)))
     (check-equal? (name f/2-rel) 'f)
     (check-equal? (arity f/2-rel) 2)
     (check-equal? (functor f/2-rel) 'f/2)
     (check-equal? (clauses f/2-rel) (list clause))))

  (test-case
   ":- 1"
   (clear-all-relations)
   (let ((clause (:- (f ?x ?y))))
     (check instance-of? clause <horn-fact>)
     (check-equal? (functor clause) 'f/2)
     (check-equal? (head clause) '(f/2 ?x ?y))
     (check-equal? (clauses (find-relation 'f 2)) (list clause))))
  
  (test-case
   ":- 2"
   (clear-all-relations)
   (let ((clause (:- (f ?x ?y) (g ?x ?y))))
     (check instance-of? clause <horn-rule>)
     (check-equal? (functor clause) 'f/2)
     (check-equal? (head clause) '(f/2 ?x ?y))
     (check-equal? (body clause) '((g/2 ?x ?y)))
     (check-equal? (clauses (find-relation 'f 2)) (list clause))))

  (test-case
   "variables"
   (clear-all-relations)
   (let ((clause (:- (f ?w ?x ?y) (g ?x ?z) (h ?z ?y))))
     (check set=? (variables '?x) (set '?x))
     (check set=? (variables clause)
	    (set '?w '?x '?y '?z)))))


(define-test-suite unification-suite
  (test-case
   "logic-variable-name"
   (check-true (logic-variable-name? '?x))
   (check-false (logic-variable-name? 'x)))

  (test-case
   "get-binding"
   (check equal? (get-binding '?x '((?x . 1) (?y . 2) (?z . 3))) '(?x . 1))
   (check equal? (get-binding '?y '((?x . 1) (?y . 2) (?z . 3))) '(?y . 2))
   (check equal? (get-binding '?z '((?x . 1) (?y . 2) (?z . 3))) '(?z . 3))
   (check eq? (get-binding '?a '((?x . 1) (?y . 2) (?z . 3))) #f))

  (test-case
   "binding-val"
   (check eqv? (binding-val '(?x . y)) 'y))

  (test-case
   "lookup"
   (check equal? (lookup '?x '((?x . 1) (?y . 2) (?z . 3))) 1)
   (check equal? (lookup '?y '((?x . 1) (?y . 2) (?z . 3))) 2)
   (check equal? (lookup '?z '((?x . 1) (?y . 2) (?z . 3))) 3))

  (test-case
   "extend-bindings"
   (check equal? (extend-bindings '?x 'y '()) '((?x . y)))
   (check equal? (extend-bindings '?x 'y '((?a . b)))
	  '((?x . y)  (?a . b))))

  (test-case
   "unify-variable"
   (check equal? (unify-variable '?x '?x '((?x . ?y))) '((?x . ?y)))
   (check equal? (unify-variable '?y '?y '((?x . ?y))) '((?x . ?y)))
   (check equal? (unify-variable '?z '?z '((?x . ?y))) '((?x . ?y)))
   (check equal? (unify-variable '?x '?z '((?x . ?y))) '((?y . ?z) (?x . ?y)))
   (check equal? (unify-variable '?x '?y '((?x . ?y))) '((?x . ?y)))
   (check equal? (unify-variable '?y '?x '((?x . ?y))) '((?x . ?y))))

  (test-case
   "unify"
   (check equal? (unify '(+ ?x 1) '(+ 2 ?y)) '((?y . 1) (?x . 2)))
   (check equal? (unify '?x '?y) '((?x . ?y)))
   (check equal? (unify '(?x ?x) '(?y ?y)) '((?x . ?y)))
   (check equal? (unify '(?x ?x ?x) '(?y ?y ?y)) '((?x . ?y)))
   (check equal? (unify '(?x ?y) '(?y ?x)) '((?x . ?y))))

  ;; TODO: Tests for occurs check.

  (test-case
   "subst-bindings"
   (check equal? (subst-bindings '((?x . 1)) '?x) 1)
   (check equal? (subst-bindings '((?x . 1)) '?y) '?y)
   (check equal? (subst-bindings '((?x . 1)) '(a ?y ?x)) '(a ?y 1))
   (check eq? (subst-bindings '((?x . 1)) '?z) '?z)
   (let ((my-list '(a ?y ?z)))
     (check eq? (subst-bindings '((?x . 1)) my-list) my-list)))

  (test-case
   "apply-unifier"
   (check equal? (apply-unifier '(?x 1) '(f ?y)) '(f 1))
   (check equal? (apply-unifier '(?x 1) '(?y 1)) '(?y 1))
   (check-false (apply-unifier '(?x 1) '(?y 2)))
   (check-false (apply-unifier '(?x 1) '(?y 1 2)))
   (check-false (apply-unifier '(?x 1 2) '(?y 1)))
   (check-false (apply-unifier '?x '(f ?x)))))


(define-test-suite logic-suite
  unification-suite
  relations-suite)

;;; TODO: delete this when the main implementation work is done and
;;; the test suite is integrated into the Poem tests.
(printf "\nRunning tests for logic.poem\n")
(run-tests logic-suite)
