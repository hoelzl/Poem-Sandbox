#lang poem

(require "utils.poem")
(require racket/set)

(provide <relation>
	 name arity functor clauses
	 add-clause variables
	 
	 all-relations clear-all-relations
	 remove-relation! find-relation set-find-relation!

	 name+arity->functor
	 predicate-names->functors
	 functor-regexp
	 parse-functor-name
	 parse-functor-description
	 functor-and-term-compatible?

	 <horn-clause>
	 functor head
	 <horn-fact>
	 <horn-rule>
	 body

	 :-

	 <logic-variable>
	 name value
	 make-logic-variable
	 logic-variable-name?
	 get-binding binding-val lookup extend-bindings
	 unify unify-variable
	 perform-occurs-check? occurs-check?
	 subst-bindings
	 apply-unifier)

;;; TODO: <relation> is not a particularly good name for the concept
;;; represented by this class, since relations can (and should) be
;;; more general than the "Prolog-like" relations represented here.
;;; --tc
(defclass <relation> ()
  (name :type <symbol>)
  (arity :type <integer>)
  (functor :type <symbol>)
  (clauses :type <list> :initvalue '())
  :printer #t
  :auto #t
  :autoaccessors :slot)

(define all-relations (make-hasheq))

(define (clear-all-relations) (setf! all-relations (make-hasheq)))

(define functor-regexp #rx"^(.+)/([1-9][0-9]*)$")

(define (name+arity->functor name arity)
  (define functor-name+arity (regexp-match functor-regexp (symbol->string name)))
  (if functor-name+arity
      (let ((functor-arity (string->number (third functor-name+arity))))
	(if (equal? arity functor-arity)
	    name
	    (string->symbol (format "~a/~a" name arity))))
      (string->symbol (format "~a/~a" name arity))))

(define (predicate-names->functors expression)
  (if (pair? expression)
      (let ((head (first expression)))
	(if (symbol? head)
	    (let ((tail (rest expression)))
	      (list* (name+arity->functor head (length tail))
		     (map predicate-names->functors tail)))
	    (map predicate-names->functors expression)))
      expression))

(define (remove-relation! name (arity #f))
  (if arity
      (let ((functor (name+arity->functor name arity)))
	(hash-remove! all-relations functor))
      (hash-remove! all-relations name)))

(define (find-relation name (arity #f))
  (if arity
      (let ((functor (name+arity->functor name arity)))
	(hash-ref all-relations functor #f))
      (hash-ref all-relations name #f)))

(define (set-find-relation! name arity new-relation)
  (if arity
      (let ((functor (name+arity->functor name arity)))
	(hash-set! all-relations functor new-relation))
      (hash-set! all-relations name new-relation)))


(define (parse-functor-name functor)
  (unless (symbol? functor)
    (error "Functor name is not a symbol:" functor))
  (define name+arity (regexp-match functor-regexp (symbol->string functor)))
  (unless name+arity
    (error "Functor name is not of the form name/arity:" functor))
  (define functor-name (string->symbol (second name+arity)))
  (define functor-arity (string->number (third name+arity)))
  ;; This error should never be triggered unless the functor-regexp is
  ;; messed up.
  (unless functor-arity
    (error "Functor arity is not a number:" functor))
  (values functor-name functor-arity))

(define (parse-functor-description functor name arity)
  (when (and functor (not (symbol? functor)))
    (error "Functor name is not a symbol:" functor))
  (when (and name (not (symbol? name)))
    (error "Relation name is not a symbol:" name))
  (when (and arity (or (not (integer? arity)) (arity . < . 0)))
    (error "Arity is not a non-negative integer:" arity))
  (cond ((and name arity)
	 (cond (functor
		(unless (equal? functor (name+arity->functor name arity))
		  (error "Name and arity do not match functor:"
			 name arity functor)))
	       (else
		(set! functor (name+arity->functor name arity)))))
	(functor
	 (define-values (functor-name functor-arity)
	   (parse-functor-name functor))
	 (if name
	     (unless (equals? name functor-name)
	       (error "Functor name and relation name do not match:"
		      functor name))
	     (set! name functor-name))
	 (if arity
	     (unless (= arity functor-arity)
	       (error "Functor arity and explicit arity do not match:"
		      functor-arity arity))
	     (set! arity functor-arity)))
	(else
	 (error "Neither name + arity nor functor were specified.")))
  (values functor name arity))


(defmethod make ((c (singleton <relation>))
		 &key functor name arity &rest initargs)
  (set!-values (functor name arity)
	       (parse-functor-description functor name arity))
  (when (getarg initargs :clauses #f)
    (error "Adding initial clauses currently not supported;"))
  (define rel (hash-ref all-relations functor #f))
  (or rel
      (let* ((rel (apply call-next-method c
			 :functor functor :name name :arity arity
			 initargs)))
	(hash-set! all-relations functor rel)
	rel)))


(define (functor-and-term-compatible? functor term)
  (and (pair? term) (eq? functor (first term))))

(defclass <horn-clause> ()
  (functor)
  (head :initializer (required-initarg :head))
  (relation)
  :auto #t
  :autoaccessors :slot)

(make-equals?-compare-class+slots <horn-clause>)

(define (clause-compatible-with-relation? clause relation)
  (equal? (functor clause) (functor relation)))

(defmethod add-clause ((relation <relation>) (clause <horn-clause>))
  (assert (clause-compatible-with-relation? clause relation))
  (setf! (clauses relation)
	 (append (clauses relation) (list clause))))

(defclass <horn-fact> (<horn-clause>))

(defclass <horn-rule> (<horn-clause>)
  (body :initializer (required-initarg :body))
  :auto #t
  :autoaccessors :slot)


(defmethod make ((class (singleton <horn-clause>))
		 &key head body &rest initargs)
  (define real-class (if (and body (not (empty? body)))
			 <horn-rule>
			 <horn-fact>))
  (define new-head (predicate-names->functors head))
  (define new-body (predicate-names->functors body))
  (define functor (first new-head))
  (define relation (find-relation functor))
  (define result
    (apply call-next-method real-class
	   :functor functor :head new-head :body new-body initargs))
  (add-clause relation result)
  result)

(define-syntax :-
  (syntax-rules ()
    ((:- (name arg ...) exp ...)
     (let* ((arity (length '(arg ...)))
	    (functor (name+arity->functor 'name arity))
	    (relation (make <relation> :name 'name :arity arity)))
       (make <horn-clause>
	 :functor functor
	 :head (predicate-names->functors '(name arg ...))
	 :body (predicate-names->functors '(exp ...))
	 :relation relation)))))

(defgeneric variables (term))

(defmethod variables ((term <horn-clause>))
  (variables (head term)))

(defmethod variables ((term <horn-rule>))
  (set-union (variables (head term)) (variables (body term))))

(defmethod variables ((term <pair>))
  (set-union (variables (first term))
	     (variables (rest term))))

(defmethod variables ((term <null>))
  (set))

(defmethod variables ((term <symbol>))
  (if (logic-variable-name? term)
      (set term)
      (set)))


(defclass <logic-variable> ()
  name
  value
  :autoaccessors :slot
  :auto #t)


;;; A simple unification algorithm, following Norvig's implementation
;;; in PAIP.

(define (logic-variable-name? x)
  (and (symbol? x)
       (eq? (string-ref (symbol->string x) 0) #\?)))

(define (get-binding var bindings)
  (assoc var bindings))

(define (binding-val binding)
  (cdr binding))

(define (lookup var bindings)
  (binding-val (get-binding var bindings)))

(define (extend-bindings var val bindings)
  (cons (cons var val) bindings))

;;; TODO: Extend with other datatypes...
(define (unify x y (bindings '()))
  (cond ((not bindings) #f)
	((eq? x y) bindings)
	((logic-variable-name? x) (unify-variable x y bindings))
	((logic-variable-name? y) (unify-variable y x bindings))
	((and (pair? x) (pair? y))
	 (unify (rest x) (rest y) (unify (first x) (first y) bindings)))
	(else #f)))

(define perform-occurs-check? (make-parameter #t))

(define (unify-variable var x bindings)
  (define (unify-binding binding)
    (unify (binding-val binding) x bindings))
  (define (unify-bound-variable binding)
    (unify var (binding-val binding) bindings))
  (cond (;; This case is never triggered when called by unify
	 (eq? var x)
	 bindings)
	((get-binding var bindings)
	 => unify-binding)
	((and (logic-variable-name? x) (get-binding x bindings))
	 => unify-bound-variable)
	((and (perform-occurs-check?) (occurs-check? var x bindings))
	 #f)
	(else
	 (extend-bindings var x bindings))))

;;; TODO: other data structures
(define (occurs-check? var x bindings)
  (cond ((eq? var x) #t)
	((and (logic-variable-name? x) (get-binding x bindings))
	 => (lambda (binding)
	      (occurs-check? var (binding-val binding) bindings)))
	((pair? x) (or (occurs-check? var (first x) bindings)
		       (occurs-check? var (rest x) bindings)))
	(else #f)))

(define (subst-bindings bindings x)
  (define (subst-binding binding)
    (subst-bindings bindings (binding-val binding)))
  (cond ((not bindings) #f)
	((null? bindings) x)
	((and (logic-variable-name? x) (get-binding x bindings))
	 => subst-binding)
	((not (pair? x)) x)
	(else
	 (reuse-cons (subst-bindings bindings (car x))
		     (subst-bindings bindings (cdr x))
		     x))))

(define (apply-unifier x y)
  (subst-bindings (unify x y) x))
