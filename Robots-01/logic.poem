#lang poem

(require "utils.poem")
(require racket/set)

(provide <relation>
	 name arity functor clauses
	 add-clause variables
	 
	 all-relations clear-all-relations
	 remove-relation! find-relation set-find-relation!

	 name+arity->functor
	 predicate-names->functors
	 functor-regexp
	 parse-functor-description

	 <horn-clause>
	 functor head
	 <horn-fact>
	 <horn-rule>
	 body
	 :-

	 <logic-variable>
	 name value
	 make-logic-variable
	 logic-variable-name?
	 get-binding binding-val lookup extend-bindings
	 unify unify-variable
	 perform-occurs-check? occurs-check?
	 subst-bindings
	 apply-unifier)

;;; TODO: <relation> is not a particularly good name for the concept
;;; represented by this class, since relations can (and should) be
;;; more general than the "Prolog-like" relations represented here.
;;; --tc
(defclass <relation> ()
  (name :type <symbol>)
  (arity :type <integer>)
  (functor :type <symbol>)
  (clauses :type <list> :initvalue '())
  :printer #t
  :auto #t
  :autoaccessors :slot)

(define all-relations (make-hasheq))

(define (clear-all-relations) (setf! all-relations (make-hasheq)))

(define (name+arity->functor name arity) 
  (string->symbol (format "~a/~a" name arity)))

(define (predicate-names->functors expression)
  (if (pair? expression)
      (let ((head (first expression)))
	(if (symbol? head)
	    (let ((tail (rest expression)))
	      (list* (name+arity->functor head (length tail))
		     (map predicate-names->functors tail)))
	    (map predicate-names->functors expression)))
      expression))

(define (remove-relation! name (arity #f))
  (if arity
      (let ((functor (name+arity->functor name arity)))
	(hash-remove! all-relations functor))
      (hash-remove! all-relations name)))

(define (find-relation name (arity #f))
  (if arity
      (let ((functor (name+arity->functor name arity)))
	(hash-ref all-relations functor #f))
      (hash-ref all-relations name #f)))

(define (set-find-relation! name arity new-relation)
  (if arity
      (let ((functor (name+arity->functor name arity)))
	(hash-set! all-relations functor new-relation))
      (hash-set! all-relations name new-relation)))


(define functor-regexp #rx"^(.+)/([1-9][0-9]*)$")

(define (parse-functor-name functor)
  (define name+arity (regexp-match functor-regexp (symbol->string functor)))
  (unless name+arity
    (error "Functor name is not of the form name/arity:" functor))
  (define functor-name (string->symbol (second name+arity)))
  (define functor-arity (string->number (third name+arity)))
  ;; This error should never be triggered unless the functor-regexp is
  ;; messed up.
  (unless functor-arity
    (error "Functor arity is not a number:" functor))
  (values functor-name functor-arity))

(define (parse-functor-description functor name arity)
  (when (and functor (not (symbol? functor)))
    (error "Functor name is not a symbol:" functor))
  (when (and name (not (symbol? name)))
    (error "Relation name is not a symbol:" name))
  (when (and arity (or (not (integer? arity)) (arity . < . 0)))
    (error "Arity is not a non-negative integer:" arity))
  (cond ((and name arity)
	 (cond (functor
		(unless (equal? functor (name+arity->functor name arity))
		  (error "Name and arity do not match functor:"
			 name arity functor)))
	       (else
		(set! functor (name+arity->functor name arity)))))
	(functor
	 (define-values (functor-name functor-arity)
	   (parse-functor-name functor))
	 (if name
	     (unless (equals? name functor-name)
	       (error "Functor name and relation name do not match:"
		      functor name))
	     (set! name functor-name))
	 (if arity
	     (unless (= arity functor-arity)
	       (error "Functor arity and explicit arity do not match:"
		      functor-arity arity))
	     (set! arity functor-arity)))
	(else
	 (error "Neither name + arity nor functor were specified.")))
  (values functor name arity))

(defmethod make ((c (singleton <relation>)) &rest initargs)
  (define func (getarg initargs :functor #f))
  (define name (getarg initargs :name #f))
  (define arity (getarg initargs :arity #f))
  (set!-values (func name arity)
	       (parse-functor-description func name arity))

  (define rel (hash-ref all-relations func #f))
  (if rel
      (let ((new-clauses (getarg initargs :clauses '())))
	(unless (null? new-clauses)
	  (setf! (clauses rel) (append (clauses rel) new-clauses)))
	rel)
      (let* ((rel (call-next-method)))
	(setf! (functor rel) func)
	(hash-set! all-relations func rel)
	rel)))

(defclass <horn-clause> ()
  (functor :initializer (required-initarg :functor))
  (head :initializer (required-initarg :head))
  :auto #t
  :autoaccessors :slot)

(make-equals?-compare-class+slots <horn-clause>)


(defmethod add-clause ((relation <relation>) (clause <horn-clause>))
  (setf! (clauses relation)
	 (append (clauses relation) (list clause))))


(defclass <horn-fact> (<horn-clause>))

(defclass <horn-rule> (<horn-clause>)
  (body :initializer (required-initarg :body))
  :auto #t
  :autoaccessors :slot)

(defgeneric variables (term))

(defmethod variables ((term <horn-clause>))
  (variables (head term)))

(defmethod variables ((term <horn-rule>))
  (set-union (variables (head term)) (variables (body term))))

(defmethod variables ((term <pair>))
  (set-union (variables (first term))
	     (variables (rest term))))

(defmethod variables ((term <null>))
  (set))

(defmethod variables ((term <symbol>))
  (if (logic-variable-name? term)
      (set term)
      (set)))

(define-syntax :-
  (syntax-rules ()
    ((:- (name arg ...))
     (let* ((arity (length '(arg ...)))
	    (functor (name+arity->functor 'name arity))
	    (relation (make <relation> :name 'name :arity arity))
	    (clause (make <horn-fact>
		     :functor functor
		     :head (list functor 'arg ...))))
       (add-clause relation clause)
       clause))
    ((:- (name arg ...) exp ...)
     (let* ((arity (length '(arg ...)))
	    (functor (name+arity->functor 'name arity))
	    (relation (make <relation> :name 'name :arity arity))
	    (clause (make <horn-rule>
		     :functor functor
		     :head (list functor 'arg ...)
		     :body (predicate-names->functors '(exp ...)))))
       (add-clause relation clause)
       clause))))

(defclass <logic-variable> ()
  name
  value
  :autoaccessors :slot
  :auto #t)


;;; A simple unification algorithm, following Norvig's implementation
;;; in PAIP.

(define (logic-variable-name? x)
  (and (symbol? x)
       (eq? (string-ref (symbol->string x) 0) #\?)))

(define (get-binding var bindings)
  (assoc var bindings))

(define (binding-val binding)
  (cdr binding))

(define (lookup var bindings)
  (binding-val (get-binding var bindings)))

(define (extend-bindings var val bindings)
  (cons (cons var val) bindings))

;;; TODO: Extend with other datatypes...
(define (unify x y (bindings '()))
  (cond ((not bindings) #f)
	((eq? x y) bindings)
	((logic-variable-name? x) (unify-variable x y bindings))
	((logic-variable-name? y) (unify-variable y x bindings))
	((and (pair? x) (pair? y))
	 (unify (rest x) (rest y) (unify (first x) (first y) bindings)))
	(else #f)))

(define perform-occurs-check? (make-parameter #t))

(define (unify-variable var x bindings)
  (define (unify-binding binding)
    (unify (binding-val binding) x bindings))
  (define (unify-bound-variable binding)
    (unify var (binding-val binding) bindings))
  (cond (;; This case is never triggered when called by unify
	 (eq? var x)
	 bindings)
	((get-binding var bindings)
	 => unify-binding)
	((and (logic-variable-name? x) (get-binding x bindings))
	 => unify-bound-variable)
	((and (perform-occurs-check?) (occurs-check? var x bindings))
	 #f)
	(else
	 (extend-bindings var x bindings))))

;;; TODO: other data structures
(define (occurs-check? var x bindings)
  (cond ((eq? var x) #t)
	((and (logic-variable-name? x) (get-binding x bindings))
	 => (lambda (binding)
	      (occurs-check? var (binding-val binding) bindings)))
	((pair? x) (or (occurs-check? var (first x) bindings)
		       (occurs-check? var (rest x) bindings)))
	(else #f)))

(define (subst-bindings bindings x)
  (define (subst-binding binding)
    (subst-bindings bindings (binding-val binding)))
  (cond ((not bindings) #f)
	((null? bindings) x)
	((and (logic-variable-name? x) (get-binding x bindings))
	 => subst-binding)
	((not (pair? x)) x)
	(else
	 (reuse-cons (subst-bindings bindings (car x))
		     (subst-bindings bindings (cdr x))
		     x))))

(define (apply-unifier x y)
  (subst-bindings (unify x y) x))
