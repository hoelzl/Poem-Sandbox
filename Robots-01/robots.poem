#lang poem

(require "logic.poem")

(defclass* <pos> ()
  x y
  :printer #t
  :autoaccessors :slot
  :auto #t)

(defmethod equals? ((pos1 <pos>) (pos2 <pos>))
  (and (= (x pos1) (x pos2))
       (= (y pos1) (y pos2))))

(defclass* <physical-object> (<logical-object>)
  (position :initvalue (make-pos 0 0))
  :autoaccessors :slot
  :auto #t)

(defclass* <brick> (<physical-object>)
  (weight :initvalue 0.1)
  :auto #t)

(defclass* <robot> (<physical-object>)
  (max-load :initvalue 0.5)
  (loaded-bricks :initvalue empty)
  :auto #t)

(defmethod initialize ((self <robot>) initargs)
  (call-next-method)
  (when (pair? (position self))
    (set! (position self)
          (apply make-pos (position self)))))

(defentityclass* <move-action> (<primitive-action>))

(define-primitive-action move (obj pos)
  :precondition true
  :effect-axiom (equals? (position obj) pos)
  (set! (position obj) pos)
  obj)

(define-primitive-action bad-move-1 (obj pos)
  :precondition #f
  :effect-axiom (equals? (position obj) pos)
  (set! (position obj) pos)
  obj)

(define-primitive-action bad-move-2 (obj pos)
  :precondition true
  :effect-axiom (not (equals? (position obj) pos))
  (set! (position obj) pos)
  obj)

