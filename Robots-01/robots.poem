#lang poem

(require "backtracking.poem")
(require "action-theory.poem")

(provide <pos> x y pos? make-pos
         <physical-object> position physical-object? 
         <brick> weight brick? make-brick
         <robot> max-load loaded-bricks robot? make-robot
         available-load
         move pick-up)

(defclass* <pos> ()
  (x :fluent #t)
  (y :fluent #t)
  :printer #t
  :autoaccessors :slot
  :auto #t
  :metaclass <logical-class>)

(defmethod equals? ((pos1 <pos>) (pos2 <pos>))
  (and (= (x pos1) (x pos2))
       (= (y pos1) (y pos2))))

(defclass* <physical-object> (<logical-object>)
  (position :initvalue (make-pos 0 0) :fluent #t)
  :autoaccessors :slot
  :auto #t
  :metaclass <logical-class>)

(defclass* <brick> (<physical-object>)
  (weight :initvalue 0.1 :fluent #t)
  :autoaccessors :slot
  :auto #t
  :metaclass <logical-class>)

(define all-robots (make-parameter empty))

(defclass* <robot> (<physical-object>)
  (max-load :initvalue 0.5 :fluent #t)
  (loaded-bricks :initvalue empty :fluent #t)
  :autoaccessors :slot
  :auto #t
  :metaclass <logical-class>)

(defmethod initialize ((self <robot>) initargs)
  (call-next-method)
  (all-robots (cons self (all-robots)))
  (when (pair? (position self))
    (set! (position self)
          (apply make-pos (position self)))))

(define (sum-all lst)
  (foldl + 0 lst))

(define (available-load robot)
  (- (max-load robot) (sum-all (map weight (loaded-bricks robot)))))

  ;; (let loop ((robots (all-robots)))
  ;;   (or (amb (first robots))
  ;;       (loop (rest robots)))))


;; (defentityclass* <move-action> (<action>))

(define-action move (obj pos)
  :precondition (physical-object? obj)
  :effect-axiom (equals? (position obj) pos)
  (set! (position obj) pos)
  obj)

(define-action move-up (obj) ;; ((obj <physical-object>))
  :precondition #t
  :effect-axiom (equals? (y (position obj))
                         (+ 1 (@pre (y (position obj)))))
  (set! (position obj) (+ 1 (position obj))))

(define-action pick-up (robot brick)
  :precondition (and (robot? robot) (brick? brick)
                     (>= (available-load robot) (weight brick)))
  :effect-axiom (equals? (loaded-bricks robot)
                         (cons brick (@pre (loaded-bricks robot))))
  (set! (loaded-bricks robot)
        (cons brick (loaded-bricks robot))))

#||
(define-action bad-move-1 (obj pos)
  :precondition #f
  :effect-axiom (equals? (position obj) pos)
  (set! (position obj) pos)
  obj)

(define-action bad-move-2 (obj pos)
  :precondition true
  :effect-axiom (not (equals? (position obj) pos))
  (set! (position obj) pos)
  obj)
||#

(define-fluent position
  (iff (position ?obj ?pos (do ?action ?situation))
       (or (and (= ?action (move ?obj ?pos)))
           (and (/= ?action (move ?obj ?pos))
                (position ?obj ?pos ?situation)))))

