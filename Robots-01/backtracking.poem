#lang poem

(provide <result-strategy>
	 collect-result
	 <all-results-strategy> <one-result-strategy>
	 <n-results-strategy>
	 number-of-results number-of-results-so-far
	 <numeric-results-strategy>
	 
	 <search-strategy>
	 next-node! add-node! add-nodes!
	 <list-search-strategy> <dfs> <bfs>
	 <ids-node> 
	 ids-node-depth set-ids-node-depth!
	 ids-node-value set-ids-node-value!

	 <ids>
	 ;;; Not sure whether these should be exported here
	 ;;; Maybe put them into a submodule for testing?
	 nodes set-nodes!
	 initial-nodes set-initial-nodes!
	 max-depth set-max-depth!
	 curr-depth set-curr-depth!
	 need-deepening? set-need-deepening?!

	 collect
	 amb deliver fail

	 an-integer->= an-integer-<= an-integer-between
	 a-multiple-of an-element-of)

(require racket/control)

;;; Search strategies

(defclass <result-strategy> ())

;; Collect a result.  The value of direct? is #t if this result was
;; directly aborted to the handler, #f otherwise.  Returns three values:
;; * Should the result be collected?
;; * Should the computation continue?
;; * The real value for the computation, for strategies that have to
;;   wrap nodes.
(defgeneric collect-result (strategy node direct?))
(defgeneric record-failure (strategy))
(defmethod record-failure (strategy)
  ;; Do nothing.
  #f)

(defclass <all-results-strategy> (<result-strategy>))

(defmethod collect-result ((strategy <all-results-strategy>) node direct?)
  (values (not (eq? node (void))) #t node))

(defclass <one-result-strategy> (<result-strategy>))

(defmethod collect-result ((strategy <one-result-strategy>) node direct?)
  (values #t #f node))

(defclass <n-results-strategy> (<result-strategy>)
  (number-of-results :initvalue 1)
  (number-of-results-so-far :initvalue 0)
  :auto #t
  :autoaccessors :slot)

(defmethod collect-result ((strategy <n-results-strategy>) node direct?)
  (inc! (number-of-results-so-far strategy))
  (define continue?
    (<= (number-of-results-so-far strategy) (number-of-results strategy)))
  (values #t
	  continue?
	  node))

(defclass <numeric-results-strategy> (<result-strategy>))

(defmethod collect-result ((strategy <numeric-results-strategy>) node direct?)
  (values (number? node) #t node))

(defclass <search-strategy> ()
  (result-strategy :initvalue (make <all-results-strategy>))
  :auto #t
  :autoaccessors :slot)

(defgeneric next-node! ((strategy <search-strategy>)))
(defgeneric add-node! ((strategy <search-strategy>) node))
(defgeneric add-nodes! ((strategy <search-strategy>) nodes))

(defmethod collect-result ((strategy <search-strategy>) node direct?)
  (collect-result (result-strategy strategy) node direct?))

(defclass <list-search-strategy> (<search-strategy>)
  (nodes :initvalue '())
  :auto #t
  :autoaccessors :slot)

(defmethod next-node! ((strategy <list-search-strategy>))
  (define ks (nodes strategy))
  (if (empty? ks)
      #f
      (begin
	(setf! (nodes strategy) (rest ks))
	(first ks))))


(defclass <dfs> (<list-search-strategy>))

(defmethod add-node! ((strategy <dfs>) k)
  (setf! (nodes strategy)
	 (list* k (nodes strategy))))

(defmethod add-nodes! ((strategy <dfs>) ks)
  (setf! (nodes strategy)
	 (append ks (nodes strategy))))


(defclass <bfs> (<list-search-strategy>))

(defmethod add-node! ((strategy <bfs>) k)
  (setf! (nodes strategy)
	 (append (nodes strategy) (list k))))

(defmethod add-nodes! ((strategy <bfs>) ks)
  (setf! (nodes strategy)
	 (append (nodes strategy) ks)))

(defentityclass <ids-node> ()
  depth
  value
  :auto #t
  :autoaccessors :class-slot)

(defaftermethod initialize ((node <ids-node>) initargs)
  (set-instance-proc! node (ids-node-value node)))

(defaftermethod set-ids-node-value! ((node <ids-node>) value)
  (set-instance-proc! node value))

(defclass <ids> (<search-strategy>)
  (nodes :initvalue '())
  (initial-nodes :initvalue #f)
  (max-depth :initvalue 1)
  (curr-depth :initvalue 0)
  (need-deepening? :initvalue #f)
  :auto #t
  :autoaccessors :slot)

(defmethod collect-result ((strategy <ids>) result direct?)
  (if (or (and (not direct?) (= (max-depth strategy) (curr-depth strategy)))
	  (and direct? (= (max-depth strategy) (add1 (curr-depth strategy)))))
      (call-next-method)
      (values #f #t #f)))

(defmethod next-node! ((strategy <ids>))
  (define ns (nodes strategy))
  (cond ((empty? ns)
	 (cond ((need-deepening? strategy)
		(unless (initial-nodes strategy)
		  (error "Iterative deepening without initial nodes?"))
		(setf! (need-deepening? strategy) #f)
		(setf! (max-depth strategy) (add1 (max-depth strategy)))
		(setf! (nodes strategy) (rest (initial-nodes strategy)))
		(let ((node (first (initial-nodes strategy))))
		  (setf! (curr-depth strategy) (ids-node-depth node))
		  node))
	       (else #f)))
	(else
	 (setf! (nodes strategy) (rest ns))
	 (let ((node (first ns)))
	   (setf! (curr-depth strategy) (ids-node-depth node))
	   node))))

(define (maybe-make-ids-node strategy val)
  (if ((curr-depth strategy) . >= . (max-depth strategy))
      (begin (setf! (need-deepening? strategy) #t) 
	     #f)
      (make <ids-node>
	:depth (add1 (curr-depth strategy))
	:value val)))

(define (maybe-make-ids-nodes strategy vals)
  (if ((curr-depth strategy) . >= . (max-depth strategy))
      (begin (setf! (need-deepening? strategy) #t) 
	     #f)
      (map (lambda (val)
	     (make <ids-node>
	       :depth (add1 (curr-depth strategy))
	       :value val))
	   vals)))

(defmethod add-node! ((strategy <ids>) k)
  (let ((new-node (maybe-make-ids-node strategy k)))
    (when new-node
      (unless (initial-nodes strategy)
	(setf! (initial-nodes strategy) (list new-node)))
      (setf! (nodes strategy)
	     (list* new-node (nodes strategy))))))

(defmethod add-nodes! ((strategy <ids>) ns)
  ;; We suppose that the new nodes are all at the same depth
  (let ((new-nodes (maybe-make-ids-nodes strategy ns)))
    (when new-nodes
      (unless (initial-nodes strategy)
	(setf! (initial-nodes strategy) new-nodes))
      (setf! (nodes strategy)
	     (append new-nodes (nodes strategy))))))


;;; Amb and friends

(define amb-tag (make-continuation-prompt-tag 'amb))
(define amb-search-strategy (make-parameter #f))

(define-syntax amb
  (syntax-rules ()
    ((_ value ...)
     (call-with-composable-continuation
      (lambda (cont)
	(add-nodes!
	 (amb-search-strategy)
	 (list (lambda ()
		 (cont value)) ...))
	(fail))
      amb-tag))))

(define (deliver value)
  (call-with-composable-continuation
   (lambda (cont)
     (define strategy (amb-search-strategy))
     (add-node!
      strategy
      (lambda ()
	(abort/cc amb-tag 'result (cont 'command-continuation))))
     (abort/cc amb-tag 'direct-result value))
   amb-tag)
  (void))

(define (fail)
  (define strategy (amb-search-strategy))
  (define cc (next-node! strategy))
  (record-failure strategy)
  (if cc
      (abort/cc amb-tag 'result (cc))
      (abort/cc amb-tag 'failure #f)))

(define-syntax collect
  (syntax-rules ()
    ((_ (search-strategy) body ...)
     (let ((result '()))
       (define (amb-handler kind value)
	 (case kind
	   ((failure)
	    (reverse result))
	   ((result direct-result)
	    (let-values (((collect-it? continue? real-value)
			  (collect-result (amb-search-strategy)
					  value
					  (eq? kind 'direct-result))))
	      (when collect-it?
		(set! result (list* value result)))
	      (when continue?
		(call-with-continuation-prompt 
		 fail amb-tag amb-handler)))
	    (reverse result))))
       (parameterize ((amb-search-strategy search-strategy))
	 (call-with-continuation-prompt
	  (thunk body ...) amb-tag amb-handler))))
    ((_ () body ...)
     (collect ((make <dfs>)) body ...))))


(define (an-integer->= n)
  (amb n (an-integer->= (+ n 1))))

(define (an-integer-<= n)
  (amb n (an-integer-<= (- n 1))))

(define (an-integer-between m n)
  (if (> m n)
      (fail)
      (amb m (an-integer-between (+ m 1) n))))

(define (a-multiple-of k)
  (let ((multiplier (an-integer->= 1)))
    (* multiplier k)))

(define (an-element-of lst)
  (if (null? lst)
      (fail)
      (amb (car lst) (an-element-of (cdr lst)))))

;;; TODO: Move the tests to test-backtracking.

(define (amb-test-01)
  (printf "Got ~a\n" (collect () (amb 1 2 3))))

(define (amb-test-02)
  (printf "Got ~a\n" 
	  (collect () (amb 1 (collect () (amb 'foo 'bar 'baz)) 2 (amb 'a 'b 'c) 3))))

(define (amb-test-03)
  (printf "Got ~a\n" 
	  (collect () (amb 1
			   (collect () (amb 'foo (fail) 'baz))
			   2
			   (fail)
			   (amb 'a 'b 'c)
			   3))))

(define (amb-test-04)
  (printf "Got ~a\n"
	  (collect ()
		   (amb 1 (begin (deliver 'a) (amb 4 5 6)) 2 (deliver 'b) 3))))

(define (amb-test-05)
  (printf "Got ~a\n"
	  (collect ()
		   (deliver 'a)
		   (deliver (amb 1 2 3))
		   (amb 'foo 'bar))))

(define (amb-test-05a)
  (printf "Got ~a\n"
	  (collect ((make <bfs>))
		   (deliver 'a)
		   (deliver (amb 1 2 3))
		   (amb 'foo 'bar))))

(define (amb-test-05b)
  (printf "Got ~a\n"
	  (collect ((make <ids>))
		   (deliver 'a)
		   (deliver (amb 1 2 3))
		   (amb 'foo 'bar))))

(define (amb-test-05c)
  (printf "Got ~a\n"
	  (collect ()
		   (deliver 'a)
		   (deliver (amb 1 (amb 2 3) 4))
		   (amb 'foo 'bar))))

(define (amb-test-05d)
  (printf "Got ~a\n"
	  (collect ((make <ids>))
		   (deliver 'a)
		   (deliver (amb 1 (amb 2 3) 4))
		   (amb 'foo 'bar))))

(define (amb-test-05e)
  (printf "Got ~a\n"
	  (collect ((make <ids> :result-strategy (make <one-result-strategy>)))
		   (deliver 'a)
		   (deliver (amb 1 (amb 2 3) 4))
		   (amb 'foo 'bar))))

(define (amb-test-05f)
  (printf "Got ~a\n"
	  (collect ((make <ids> :result-strategy (make <numeric-results-strategy>)))
		   (deliver 'a)
		   (deliver (amb 1 (amb 2 3) 4))
		   (amb 'foo 'bar))))

(define (amb-test-06)
  (collect ((make <ids>)) (amb 1 2 (amb 'a (amb 'x 'y) 'b) 3)))

(define (amb-test-06a)
  (collect ((make <ids> :result-strategy (make <one-result-strategy>)))
	   (amb 1 2 (amb 'a (amb 'x 'y) 'b) 3)))




