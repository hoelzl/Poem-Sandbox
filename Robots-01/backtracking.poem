#lang poem

(require racket/control)
(provide clear-all-choice-points
	 unfail-all-callsites
	 set-default-error-proc!
         more-choice-points?
         create-choice-points amb
         fail fail-once
         bag-of
         amb-assert
	 an-integer->= an-integer-<= an-integer-between
	 a-multiple-of an-element-of)

(defstruct <choice-point> ()
  prompt-tag
  proc
  cont)

(define (invoke-choice-point cp)
  ((choice-point-cont cp) ((choice-point-proc cp))))

(define all-choice-points '())

(define (clear-all-choice-points)
  (set! all-choice-points '()))

(define (more-choice-points?)
  (not (null? all-choice-points)))

(define default-error-proc (thunk (error "No next choice point")))

(define (set-default-error-proc! proc)
  (set! default-error-proc proc))

(define (next-choice-point (error-proc default-error-proc))
  ;; (printf "Called next-choice-point\n")
  (if (null? all-choice-points)
      (error-proc)
      (let ((first-cp (first all-choice-points)))
	;; (printf "Returning choice point ~a\n" first-cp)
        (set! all-choice-points (rest all-choice-points))
        first-cp)))

(define-syntax maybe-abort/cc
  (syntax-rules ()
    ((_ tag exp)
     (if (continuation-prompt-available? tag)
	 (abort/cc tag exp)
	 (exp)))))

(define-syntax abort/default
  (syntax-rules ()
    ((_ exp)
     (abort/cc
      (default-continuation-prompt-tag)
      exp))))

(define-syntax maybe-abort/default
  (syntax-rules ()
    ((_ exp)
     (maybe-abort/cc (default-continuation-prompt-tag) exp))))

;;; TODO: `fail-handler' and `fail' are exactly the same...

(define (fail-handler)
  ;; (printf "Calling fail-handler\n")
  (abort/default call-next-choice-point))

(define (call-next-choice-point (error-proc default-error-proc))
  ;; (printf "Calling call-next-choice-point\n")
  (define cp (next-choice-point error-proc))
  (cond (cp
	 ;; (printf "Found choice point\n")
	 (let ((prompt-tag (choice-point-prompt-tag cp))
	       (proc (thunk (invoke-choice-point cp))))
	   (call-with-continuation-prompt proc prompt-tag fail-handler)))
	(else
	 ;; (printf "call-next-choice-point: no next choice point\n")
	 (error-proc))))
  
(define (fail)
  ;; (printf "Called fail\n")
  ;; (printf "Choice points: ~a\n" all-choice-points)
  (abort/default call-next-choice-point))

(define (make-fail-once-proc)
  (define failed? #f)
  (thunk
   (cond ((failed?)
	  ;; (printf "fail-once: failed before\n")
	  (values))
	 (else
	  ;; (printf "fail-once: failing for the first time\n")
	  (set! failed? #t)
	  (fail)))))

(define failed-call-sites (make-hash))

(define (unfail-all-callsites)
  (set! failed-call-sites (make-hash)))
;; (define no-such-callsite (gensym))

#||
(define-syntax fail-once
  (lambda (stx)
    (syntax-case stx ()
      ((_) (let ((id (gensym)))
	     #`(when (eq? no-such-callsite
			    (hash-ref failed-call-sites '#,id no-such-callsite))
		 (let* ((cp (next-choice-point))
			(val (call-with-continuation-prompt 
			      (choice-point-proc cp)
			      (choice-point-prompt-tag cp)
			      (lambda (cont)
				(printf "fail-once: invoking continuation\n")
				(cont)))))
		   (hash-set! failed-call-sites '#,id val)
		   (abort/default (thunk val)))))))))
||#

(define-syntax fail-once
  (lambda (stx)
    (syntax-case stx ()
      ((_) (let ((id (gensym)))
	     #`(if (hash-ref failed-call-sites '#,id #f)
		   'failed-before
		   (begin
		     (hash-set! failed-call-sites '#,id #t)
		     (fail))))))))

; (fail-once)

(define (create-choice-points form . thunks)
  (define tag (make-continuation-prompt-tag))
  (call-with-composable-continuation
   (lambda (comp)
     (let ((new-cps (map (lambda (proc)
			   (define new-cont
			     (lambda (proc)
			      ;; (printf "~a: Calling stored cont\n" form)
			      (comp (proc))))
			   (define new-proc
			     (thunk
			      ;; (printf "~a: Calling stored proc\n" form)
			      proc))
			   (choice-point tag new-proc new-cont))
			 thunks)))
       (set! all-choice-points
	     (append new-cps all-choice-points)))
     (call-next-choice-point))))

(define-syntax-rule (amb alt ...)
  (create-choice-points '(amb alt ...) (thunk alt) ...))

(define (amb-assert exp)
  (unless exp
    (fail)))

(define-syntax-rule (bag-of exp)
  (begin
    ;; TODO: Maybe parameterize this?
    (clear-all-choice-points)
    (letrec ((bag-of-handler
	      (lambda (res)
		;; (printf "Called bag-of-handler ~a\n" res)
		(call-with-continuation-prompt
		 res
		 (default-continuation-prompt-tag)
		 bag-of-handler))))
      (let ((saved-error-proc default-error-proc)
	    (result '()))
	(call-with-current-continuation
	 (lambda (exit)
	   (set-default-error-proc!
	     (lambda ()
	       ;; (printf "Calling exit procedure\n")
	       (set-default-error-proc! saved-error-proc)
	       ;; (printf "Calling exit\n")
	       (exit (void))))
	   (let* ((init-value (call-with-continuation-prompt
			       (thunk exp)
			       (default-continuation-prompt-tag)
			       bag-of-handler)))
	     (unless (void? init-value)
	       (set! result (list init-value)))
	     (define (loop)
	       ;; (printf "Starting loop with result = ~a\n" result)
	       ;; (printf "Number of choice points = ~a\n" (length all-choice-points))
	       (if (more-choice-points?)
		   (let ((value (call-with-continuation-prompt
				 call-next-choice-point
				 (default-continuation-prompt-tag)
				 bag-of-handler)))
		     ;; (printf "Got value ~a\n" value)
		     (unless (void? value)
		       (set! result (cons value result)))
		     (abort/default loop))
		   (reverse result)))
	     (begin0 (loop)
	       (set-default-error-proc! saved-error-proc)))))))))

(define (an-integer->= n)
  (amb n (an-integer->= (+ n 1))))

(define (an-integer-<= n)
  (amb n (an-integer-<= (- n 1))))

(define (an-integer-between m n)
  (if (> m n)
      (fail)
      (amb m (an-integer-between (+ m 1) n))))

(define (a-multiple-of k)
  (let ((multiplier (an-integer->= 1)))
    (* multiplier k)))

(define (an-element-of lst)
  (if (null? lst)
      (fail)
      (amb (car lst) (an-element-of (cdr lst)))))

