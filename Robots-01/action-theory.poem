#lang poem

(provide <situation>
         actions
         current-situation
         do!
         <logical-class>
         <logical-object>
         <action>
         name
         parameters
         precondition
         effect-axiom
         assert
         define-action
         @pre
         <action-instance>
         action
         arguments
         <fluent>
         axiom
         all-fluents
         define-fluent)

;;; TODO: Fix printing.

(define print-situation
  (lambda (obj rec? &opt [port (current-output-port)])
    (let ((printer (if rec? write-object display-object)))
      (printer (format "#<situation: actions=~a>"
                       (map (lambda (ai)
                              (format "#<action-instance: ~a arguments=~a>"
                                      (name (action ai))
                                      (map (lambda (arg) (format "~a" arg))
                                           (arguments ai))))
                            (actions obj)))))))

(defclass* <situation> ()
  (actions :initvalue empty)
  :printer print-situation
  :autoaccessors :slot
  :auto #t)

(define current-situation (make-parameter (make <situation>)))

(define (do! action situation)
  (make-situation (cons action (actions situation))))

(define all-fluents (make-hash-table))

(defclass* <fluent> ()
  name
  axiom
  :auto #t
  :autoaccessors :slot
  :printer #t)

(define (maybe-make-fluent name)
  (unless (hash-table-get all-fluents name #f)
    (hash-table-put! all-fluents name (make-fluent name))))

(define-syntax-rule (define-fluent name axiom)
  (make-fluent 'name 'axiom))

(defclass* <logical-class> (<class>)
  :printer #t)

(defmethod compute-slots ((class <logical-class>))
  (let ((slots (call-next-method)))
    (for ((slot (in-list slots)))
      (when (getarg (rest slot) :fluent #f)
        (printf "Creating fluent ~a\n" (first slot))
        (maybe-make-fluent (first slot))))
    slots))

(defclass* <logical-object> ()
  :printer #t)

(defentityclass* <action> ()
  name
  parameters
  precondition
  effect-axiom
  :printer #t
  :autoaccessors :slot
  :auto #t)

(defclass* <action-instance> ()
  action
  arguments
  :printer #t
  :autoaccessors :slot
  :auto #t)

(define-syntax-rule (assert expression ...)
  (unless (begin expression ...)
    (error "Assertion failed: " '(assert expression ...))))

(define-syntax define-action
  (lambda (stx)
    (syntax-case stx ()
      ((_ id exp1
          :precondition exp2
          :effect-axiom exp3
          exp ...)
       #'(define id
           (let ((act (make <action>
                           :name 'id
                           :parameters 'exp1
                           :precondition 'exp2
                           :effect-axiom 'exp3)))
             (set-instance-proc! act
                                 (lambda exp1
                                   (assert exp2)
                                   (current-situation (do! (make-action-instance
                                                            act (list . exp1))
                                                           (current-situation)))
                                   (begin0
                                       (begin
                                         exp ...)
                                     (assert exp3))))
             act))))))

(define (@pre exp)
  exp)
