#lang poem

(require "utils.poem")
(require "backtracking.poem")

(provide <situation>
         actions
         current-situation
         do!
	 copy-situation
         <logical-class>
         <logical-object>
         <action-type>
	 make-action-proc
         name
         parameters
         precondition
         effect-axiom
	 proc-body
         assert
         all-action-type-names
         action-type-name? get-action-type
         define-action-type
         @pre
         <action>
         action-type
         arguments
         <fluent>
         axiom
         all-fluent-names
         fluent-name? get-fluent
         define-fluent)

(defclass <situation> ()
  (actions :initvalue (make <var>))
  :auto #t
  :autoaccessors #f)

(defaftermethod initialize ([sit <situation>] initargs)
  (define actions-val (slot-ref sit 'actions))
  (when (eq? (value actions-val) ???)
    (set-value! actions-val '())))

(defmethod actions ([sit <situation>])
  (value (slot-ref sit 'actions)))

(defmethod set-actions! ([sit <situation>] new-actions)
  (set-value! (slot-ref sit 'actions) new-actions))

(define current-situation (make-parameter (make <situation>)))

(define (do! action situation)
  (define new-var (make <var>))
  (set-value! new-var (cons action (actions situation)))
  (make-situation new-var))

(define (copy-situation situation)
  (make-situation (actions situation)))

(define all-fluent-names (make-hash))

(define (fluent-name? name)
  (and (hash-ref all-fluent-names name #f) #t))

(define (get-fluent name)
  (hash-ref all-fluent-names name))

(defclass <fluent> ()
  name
  axiom
  :auto #t
  :autoaccessors :slot
  :printer #t)

;;; Maybe generate `name?' as a predicate for the fluent?
(define (maybe-make-fluent name)
  (unless (hash-ref all-fluent-names name #f)
    (hash-set! all-fluent-names name (make-fluent name))))

(define-syntax-rule (define-fluent name axiom)
  (make-fluent 'name 'axiom))

(defclass <logical-class> (<class>)
  :printer #t)

;;; TODO: initialize slots with vars and generate getters and setters
;;; similar to `actions' for <situation>.
(defmethod compute-slots ([class <logical-class>])
  (let ([slots (call-next-method)])
    (for ([slot (in-list slots)])
      (when (getarg (rest slot) :fluent #f)
        ;; (printf "Creating fluent ~a\n" (first slot))
        (maybe-make-fluent (first slot))))
    slots))

(defclass <logical-object> ()
  :printer #t)

(define all-action-type-names (make-hash))

(define (action-type-name? name)
  (and (hash-ref all-action-type-names name #f) #t))

(define (get-action-type name)
  (hash-ref all-action-type-names name))

(defentityclass <action-type> ()
  name
  (parameters :initivalue '())
  (precondition :initvalue '())
  (effect-axiom :initvalue '())
  (proc-body :initvalue '())
  :printer #t
  :autoaccessors :slot
  :auto #t)

(define (make-action-proc action-name parameters precondition body)
  #`(lambda #,parameters
      (assert #,precondition)
      (current-situation (do! (make-action
			       #,action-name (list #,@parameters))
			      (current-situation)))
      . #,body))

(define-for-syntax (make-action-proc action-name parameters precondition body)
  `(lambda ,parameters
      (assert ,precondition)
      (current-situation (do! (make-action
			       ,action-name (list ,@parameters))
			      (current-situation)))
      ,@body))

(defaftermethod initialize ([action <action-type>] initargs)
  (hash-set! all-action-type-names (name action) action)
  #;
  (set-instance-proc! act (make-action-proc action)))

(defclass <action> ()
  action-type
  arguments
  :printer #t
  :autoaccessors :slot
  :auto #t)

(defmethod add-action! ([sit <situation>] [act <action>])
  (set-actions! sit (list* act (actions sit))))

(defmethod name ([act <action>])
  (name (action-type act)))

(defmethod signature ([act <action>])
  (signature (action-tyep act)))

(define (convert-to-axiom id args precondition body)
  body)

(define-syntax define-action-type
  (lambda (stx)
    (syntax-case stx ()
      [(_ id args
          :precondition precondition
          exp ...)
       #'(define id
           (let ([act (make <action-type>
                        :name 'id
                        :parameters 'args
                        :precondition 'precondition
			:proc-body '(exp ...)
                        :effect-axiom (convert-to-axiom
				       'id 'args 'precondition '(exp ...)))])
	     (set-instance-proc! 
	      act
	      (lambda args
		; (assert precondition)
		(current-situation (do! (make-action
					 id (list . args))
					(current-situation)))
		(printf "Action: ~a\n" (make-action id (list . args)))
		(printf "Situation: ~a\n" (do! (make-action
						id (list . args))
					       (current-situation)))
		exp ...))
             act))]
      [(_ id args exp ...)
       #'(define-action-type id args :precondition true exp ...)])))

(define (@pre exp)
  exp)


;;; TODO: Argument list for fluent?
;;; Declare sorts for each type of logical objects
;;; Declare constructors for each sort

(define (generate-domain-theory)
  (generate-successor-state-axioms))

(define (generate-successor-state-axioms)
  (for ((fluent-name (in-hash-keys all-fluent-names)))
    (generate-successor-state-axiom-for-fluent fluent-name)))

(defclass <successor-state-part> ()
  axiom-head
  previous-value
  :autoaccessors #t
  :auto #t)

#||
;; (generate-successor-state-axiom-for-fluent position)
(effect-axiom (get-action-type 'move))
  => (equals? (position obj) pos)
(make-successor-state-part '(position obj (do (move obj pos) sit))
                           'pos)
(effect-axiom (get-action-type 'move-up))
  => (equals? (position obj)
              (make-position (@pre (x (position obj)))
                             (+ 1 (@pre (y (position obj))))))
(make-successor-state-part '(position obj (do (move-up obj) sit))
                           '(make-position (x (position obj sit))
                                           (+ 1 (y (position obj sit)))))
||#

(define (generate-successor-state-axiom-for-fluent fluent-name)
  (let ([parts (generate-successor-state-parts-for-fluent fluent-name)])
    (build-successor-state-axiom-from-parts parts)))

(define (generate-successor-state-parts-for-fluent fluent-name)
  (for/list ([(action-type-name action) (in-hash all-action-type-names)])
    (let-values ([(relevant? new-formula previous-formula)
                  (extract-successor-state-parts action fluent-name)])
      ; #:break (not relevant?)
      (make-successor-state-part new-formula previous-formula))))

(define (build-successor-state-axiom-from-parts)
  #f)

(define (extract-successor-state-parts action fluent-name)
  #f)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Some tests for interactive debugging
;;; Delete when the test suite runs


(define fluent-1 (make <fluent>
		   :name 'fluent-1
		   :axiom '(foo)))


(define move-action (make <action-type>
		      :name 'move
		      :parameters '(robot pos)
		      :precondition '(not (exists (r <robot>)
						  (and (not (equal? robot r))
						       (equal? (position-of r now) pos))))
		      :effect-axiom '(equal? (position-of robot (do! (move robot pos) now))
					     pos)
		      :proc-body '((setf! (position-of robot (do! (move robot pos) now))
					   pos))))


(define test-action-1 (make <action-type>
			:name 'test-action-1
			:parameters '(arg1)
			:precondition '(number? arg1)
			:effect-axiom '()))

(define test-action-2 (make <action-type>
			:name 'test-action-2
			:parameters '(arg1 arg2)
			:precondition '()
			:effect-axiom '()))

#;
(pretty-print
 (syntax->datum (make-action-proc (name move-action)
				  (parameters move-action)
				  (precondition move-action)
				  (proc-body move-action))))
